var fs = require("fs"),
    path = require("path"),
    svgPattern = /<svg[\w\W]*?>([\w\W]*)<\/svg>/,
    SVGO = require("svgo"),
    svg2js = require("svgo/lib/svgo/svg2js"),
    Promise = require("promise"),
    util = require("./util"),
    readFile = Promise.denodeify(fs.readFile),
    writeFile = Promise.denodeify(fs.writeFile),
    readDir = Promise.denodeify(fs.readdir),
    defaultComment = "This file was generated by polymer-iconset-generator " +
        "(https://github.com/maklesoft/polymer-iconset-generator)";

/**
 * Parse dimensions from svg code by looking for `width` and `height` attributes on svg tag
 * @param {string} svg
 * @return {Promise}
 */
function parseDimensions(svg) {
    return new Promise(function(resolve) {
        svg2js(svg, function(result) {
            var ret = {
                svg: svg
            };
            try {
                var svgElem = result.content.filter(function(el) {
                    return el.elem === "svg";
                })[0];
                ret.dimensions = {
                    width: parseInt(svgElem.attr("width").value.replace("px", ""), 10),
                    height: parseInt(svgElem.attr("height").value.replace("px", ""), 10)
                };
            } catch (e) {
                // Leave dimensions undefined
            }
            resolve(ret);
        });
    });
}

/**
 * Clean up svg code via svgo
 * @param {string} svg
 * @param {object} opts
 * @return {Promise}
 */
function clean(svg, opts) {
    opts = opts || {};
    var plugins = [
        {removeTitle: true},
        {removeDesk: {removeAny: true}}
    ];

    if (opts.monochrome) {
        plugins.push(
            {removeStyleElement: true},
            {removeAttrs: {attrs: ["class", "fill", "stroke"]}}
        );
    }

    var svgo = new SVGO({
        quiet: true,
        js2svg: {
            pretty: !opts.minify
        },
        plugins: plugins
    });

    return new Promise(function(resolve, reject) {
        svgo.optimize(svg, function(result) {
            if (result.error) {
                reject(result.error);
            }
            var ret = {
                svg: result.data
            };
            try {
                ret.dimensions = {
                    width: result.info.width && parseInt(result.info.width, 10),
                    height: result.info.height && parseInt(result.info.height, 10)
                };
            } catch(e) {
                // Leave dimensions undefined
            }
            resolve(ret);
        });
    });
}

/**
 * Read a svg file and extract it's contents (groups, paths and such without the boilerplate)
 *
 * @param {string} file - The filename
 * @param {object} opts - Object containing various options
 * @return {Promise}
 */
function processFile(file, opts) {
    opts = opts || {};
    var prefix = opts.prefix || "";
    var omitPrefix = opts.omitPrefix || "";
    // Icon names are derived from file names
    var name = path.basename(file, ".svg");
    // Remove common prefix if option is provided
    if (omitPrefix && name.startsWith(omitPrefix)) {
        name = name.substr(omitPrefix.length);
    }
    // Add provided prefix
    name = prefix + name;

    return readFile(file, {encoding: "utf-8"})
        .then(function(content) {
            // If `clean` option is set, run the svg code through the optimizer. If not, only parse the icon
            // dimensions, but only if the size is not already provided through the options
            return opts.clean ? clean(content, opts) :
                opts.size ? {svg: content} : parseDimensions(content);
        })
        .then(function(result) {
            var match = result.svg.match(svgPattern);
            var svg = match ? "\n<g id=\"" + name + "\">\n" + match[1] + "\n</g>" : "";
            return {
                name: name,
                svg: svg,
                dimensions: result.dimensions
            }
        });
}

/**
 * Read a directories contents and extract svg definitions from all .svg files within
 * For details on the options object see the documentation for `processFile()`
 *
 * @param {string} dir
 * @param {object} opts
 * @return {Promise}
 */
function processDir(dir, opts) {
    return readDir(dir)
        .then(function(files) {
            var svgFiles = files.filter(function(file) {
                return path.extname(file) == ".svg";
            });

            // If no explicit prefix is provided for omission, try to detect the longest common prefix
            // automatically
            opts.omitPrefix = opts.omitPrefix !== undefined ?
                opts.omitPrefix : util.detectCommonPrefix(svgFiles);

            var promises = svgFiles.map(function(file) {
                var fullPath = path.join(dir, file);
                return processFile(fullPath, opts);
            });

            return Promise.all(promises);
        });
}

/**
 * Returns the maximum size from a list of icon definitions
 * @param {object[]} defs
 * @return {number}
 */
function maxSize(defs) {
    return defs.reduce(function(curr, def) {
        var width = def.dimensions && def.dimensions.width || 0;
        var height = def.dimensions && def.dimensions.height || 0;
        return def.dimensions ? Math.max(curr, width, height) : curr;
    }, 0);
}

/**
 * Generates html for icon set file from a set of icon definitions
 *
 * @param {Array} defs - Array of icon definitions
 * @param {object} opts - Options object
 * @return {string}
 */
function generateHTML(defs, opts) {
    opts = opts || {};
    var setName = opts.name;
    var size = opts.size || maxSize(defs) || 100;
    var importPath = path.relative(
        path.dirname(opts.dest),
        path.join(opts.bowerPath, "/iron-iconset-svg/iron-iconset-svg.html")
    );
    var libImport = "<link rel=\"import\" href=\"" + importPath + "\">";
    var svg = defs.map(function(def) {
        return def.svg;
    }).join("\n");
    var comment = opts.comment || defaultComment;
    comment = comment != "none" ? "<!--\n" + comment + "\n-->\n\n" : "";

    return comment +
        libImport + "\n\n" +
        "<iron-iconset-svg name=\"" + setName + "\" size=\"" + size + "\">\n" +
        "<svg>\n" +
        "<defs>\n" +
        svg +
        "\n\n</defs>\n" +
        "</svg>\n" +
        "</iron-iconset-svg>\n";
}

function generateDemo(defs, opts) {
    function importPath(relPath) {
        return path.relative(
            path.dirname(opts.dest),
            path.join(opts.bowerPath, relPath)
        );
    }

    var iconsetImportPath = path.relative(path.dirname(opts.demoPath), opts.dest);

    return "" +
        "<html>\n" +
        "  <head>\n" +
        "    <title>" + opts.name + " icon set demo</title>\n" +
        "    <script src=\"" + importPath("webcomponentsjs/webcomponents-lite.min.js") + "\"></script>\n" +
        "    <link rel=\"import\" href=\"" + importPath("polymer/polymer.html") + "\">\n" +
        "    <link rel=\"import\" href=\"" + importPath("iron-icon/iron-icon.html") + "\">\n" +
        "    <link rel=\"import\" href=\"" + iconsetImportPath + "\">\n" +
        "  </head>\n" +
        "  <body>\n" +
        defs.map(function(def) {
            return "    <iron-icon icon=\"" + opts.name + ":" + def.name + "\"></iron-icon>";
        }).join("\n") + "\n" +
        "  </body>\n" +
        "</html>\n" +
        "";
}

/**
 * Generates a iconset file for a given directory of svg icons
 *
 * The options argument may contain the following options:
 *
 *     {
 *         name: [name of source dir], // Name for the icon set
 *         size: 100, // Icon size
 *         dest: "[srcDir]/[name].html", // File or directory path of destination file
 *         bowerPath: "./bower_components", // Path to bower_components folder
 *         prefix: "", // Prefix to add to file names for icon names
 *         omitPrefix: "" // Common prefix in file name to be omitted from icon names
 *     }
 *
 * @param {string} srcDir - Directory containing the icons
 * @param {object} opts - Options object
 * @return {Promise}
 */
function generate(srcDir, opts) {
    opts = opts || {};

    // If there is a config file in the cwd, use it
    try {
        util.extend(opts, require(path.resolve(process.cwd(), "pigcfg.json")), false);
    } catch (e) {}
    // If there is a config file in this directory, use it
    try {
        util.extend(opts, require(path.resolve(srcDir, "pigcfg.json")), false);
    } catch (e) {}

    opts.name = opts.name || path.basename(srcDir);
    var dest = opts.dest || srcDir;
    opts.dest = path.extname(dest) == ".html" ? dest : path.join(dest, opts.name + ".html");
    opts.bowerPath = opts.bowerPath || "./bower_components";
    opts.demoPath = opts.demo &&
        path.join(path.dirname(opts.dest), path.basename(opts.dest, ".html") + "-demo.html");

    return processDir(srcDir, opts)
        .then(function(defs) {
            if (!defs.length) {
                return Promise.resolve();
            }

            var html = generateHTML(defs, opts);
            var promises = [writeFile(opts.dest, html)];
            if (opts.demo) {
                var demo = generateDemo(defs, opts);
                promises.push(writeFile(opts.demoPath, demo));
            }
            return Promise.all(promises);
        });
}

module.exports = generate;
